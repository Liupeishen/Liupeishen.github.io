<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十大排序算法-golang</title>
    <link href="/2022/07/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-golang/"/>
    <url>/2022/07/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-golang/</url>
    
    <content type="html"><![CDATA[<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p><strong>算法步骤</strong></p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>   length := <span class="hljs-built_in">len</span>(nums)<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>      <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; length<span class="hljs-number">-1</span>-i; j++ &#123;<br>         <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] &#123;<br>            nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>         &#125;<br>      &#125;<br>   &#125;<br>   fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><p> <strong>算法步骤</strong></p><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>   length := <span class="hljs-built_in">len</span>(arr)<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length<span class="hljs-number">-1</span>; i++ &#123;<br>      min := i<br>      <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length; j++ &#123;<br>         <span class="hljs-keyword">if</span> arr[min] &gt; arr[j] &#123;<br>            min = j<br>         &#125;<br>      &#125;<br>      arr[i], arr[min] = arr[min], arr[i]<br>   &#125;<br>   fmt.Println(arr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><p><strong>算法步骤</strong></p><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;<br>      preIndex := i - <span class="hljs-number">1</span><br>      current := arr[i]<br>      <span class="hljs-keyword">for</span> preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current &#123;<br>         arr[preIndex+<span class="hljs-number">1</span>] = arr[preIndex]<br>         preIndex -= <span class="hljs-number">1</span><br>      &#125;<br>      arr[preIndex+<span class="hljs-number">1</span>] = current<br>   &#125;<br>   fmt.Println(arr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><p><strong>算法步骤</strong></p><img src="b674a6b489086.png" alt="image-20210310105042665" style="zoom: 67%;" /><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>   length := <span class="hljs-built_in">len</span>(arr)<br>   <span class="hljs-keyword">for</span> gap := length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap = gap / <span class="hljs-number">2</span> &#123;<br>      <span class="hljs-keyword">for</span> i := gap; i &lt; length; i++ &#123;<br>         temp := arr[i]<br>         j := i - gap<br>         <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp &#123;<br>            arr[j+gap] = arr[j]<br>            j -= gap<br>         &#125;<br>         arr[j+gap] = temp<br>      &#125;<br>   &#125;<br>   fmt.Println(arr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><p>归并排序的主要思想是：把待排序的文件分成若干个子文件，先将每个子文件内的记录排序，再将已排序的子文件合并，得到完全排序的文件。</p><p><strong>算法步骤</strong></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>   length := <span class="hljs-built_in">len</span>(arr)<br>   <span class="hljs-keyword">if</span> length &lt; <span class="hljs-number">2</span> &#123;<br>      <span class="hljs-keyword">return</span> arr<br>   &#125;<br>   middle := length / <span class="hljs-number">2</span><br>   left := arr[:middle]<br>   right := arr[middle:]<br>   <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>   <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(left) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(right) != <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">if</span> left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>] &#123;<br>         result = <span class="hljs-built_in">append</span>(result, left[<span class="hljs-number">0</span>])<br>         left = left[<span class="hljs-number">1</span>:]<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         result = <span class="hljs-built_in">append</span>(result, right[<span class="hljs-number">0</span>])<br>         right = right[<span class="hljs-number">1</span>:]<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(left) != <span class="hljs-number">0</span> &#123;<br>      result = <span class="hljs-built_in">append</span>(result, left[<span class="hljs-number">0</span>])<br>      left = left[<span class="hljs-number">1</span>:]<br>   &#125;<br>   <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(right) != <span class="hljs-number">0</span> &#123;<br>      result = <span class="hljs-built_in">append</span>(result, right[<span class="hljs-number">0</span>])<br>      right = right[<span class="hljs-number">1</span>:]<br>   &#125;<br>   <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><p>快速排序(QuickSort) 是由冒泡排序改进而得的。在冒泡排序过程中， 只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。</p><p><strong>算法步骤</strong></p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">return</span> quickSort(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">if</span> low &lt; high &#123;<br>      mid := partition(arr, low, high)<br>      quickSort(arr, low, mid<span class="hljs-number">-1</span>)<br>      quickSort(arr, mid+<span class="hljs-number">1</span>, high)<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   tmp := arr[low]<br>   <span class="hljs-keyword">for</span> low &lt; high &#123;<br>      <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; arr[high] &gt;= tmp &#123;<br>         high--<br>      &#125;<br>      arr[low] = arr[high]<br>      <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; arr[low] &lt;= tmp &#123;<br>         low++<br>      &#125;<br>      arr[high] = arr[low]<br>   &#125;<br>   arr[low] = tmp<br>   <span class="hljs-keyword">return</span> low<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><p><strong>算法步骤</strong></p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>   arrLen := <span class="hljs-built_in">len</span>(arr)<br>   buildMaxHeap(arr, arrLen)<br>   <span class="hljs-keyword">for</span> i := arrLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>      swap(arr, <span class="hljs-number">0</span>, i)<br>      arrLen -= <span class="hljs-number">1</span><br>      adjustHeap(arr, <span class="hljs-number">0</span>, arrLen)<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, arrLen <span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := arrLen / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>      adjustHeap(arr, i, arrLen)<br>   &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, i, arrLen <span class="hljs-type">int</span>)</span></span> &#123;<br>   left := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span><br>   right := <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span><br>   largest := i<br>   <span class="hljs-keyword">if</span> left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] &#123;<br>      largest = left<br>   &#125;<br>   <span class="hljs-keyword">if</span> right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] &#123;<br>      largest = right<br>   &#125;<br>   <span class="hljs-keyword">if</span> largest != i &#123;<br>      swap(arr, i, largest)<br>      adjustHeap(arr, largest, arrLen)<br>   &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>   arr[i], arr[j] = arr[j], arr[i]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><p>参考：<a href="https://www.cxyxiaowu.com/5437.html">漫画：什么是计数排序？-五分钟学算法 </a></p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><img src="image-20220814223244103.png" alt="image-20220814223244103" style="zoom:67%;" /><img src="image-20220814223313837.png" alt="image-20220814223313837" style="zoom:67%;" /><p><strong>算法步骤</strong></p><p> 算法的步骤如下：</p><p>（1）找出待排序的数组中最大和最小的元素</p><p>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p><p>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p><p>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> max = arr[<span class="hljs-number">0</span>]<br>   <span class="hljs-keyword">var</span> min = arr[<span class="hljs-number">0</span>]<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>      <span class="hljs-keyword">if</span> arr[i] &gt; max &#123;<br>         max = arr[i]<br>      &#125;<br>      <span class="hljs-keyword">if</span> arr[i] &lt; min &#123;<br>         min = arr[i]<br>      &#125;<br>   &#125;<br>   count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, max-min+<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>      count[v-min]++<br>   &#125;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> count &#123;<br>      <span class="hljs-keyword">if</span> v != <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; v; j++ &#123;<br>            arr[i] = min + k<br>            i++<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p><strong>1. 什么时候最快</strong></p><p>当输入的数据可以均匀的分配到每一个桶中。</p><p><strong>2. 什么时候最慢</strong></p><p>当输入的数据被分配到了同一个桶中。</p><p><strong>3. 示意图</strong></p><p>元素分布在桶中：</p><img src="image-20220814225129688.png" alt="image-20220814225129688" style="zoom:67%;" /><img src="image-20220814225225031.png" alt="image-20220814225225031" style="zoom:67%;" /><img src="079dbab6a522f.png" alt="image-20210311105823407" style="zoom:67%;" /><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, max, num <span class="hljs-type">int</span>)</span></span> &#123;<br>   buckets := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, num)<br>   <span class="hljs-keyword">var</span> index <span class="hljs-type">int</span><br>   <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>      index = v * (num - <span class="hljs-number">1</span>) / max<br>      buckets[index] = <span class="hljs-built_in">append</span>(buckets[index], v)<br>   &#125;<br>   tmpPos := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br>      bucketLen := <span class="hljs-built_in">len</span>(buckets[i])<br>      <span class="hljs-keyword">if</span> bucketLen &gt; <span class="hljs-number">0</span> &#123;<br>         insert_Sort(buckets[i])<br>         <span class="hljs-built_in">copy</span>(arr[tmpPos:], buckets[i])<br>         tmpPos += bucketLen<br>      &#125;<br>   &#125;<br>   fmt.Println(arr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值</li></ul><p>基数排序按取数方向分为两种：从左取每个数列上的数，为<strong>最高位优先（Most Significant Digit first, MSD）</strong>；从右取每个数列上的数，为<strong>最低位优先（Least Significant Digit first, LSD）</strong>。下列以LSD为例。</p><p><strong>基数排序步骤</strong>：</p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li><li>从最低位开始，依次进行一次排序</li><li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li></ul><p><strong>代码实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(theArray []<span class="hljs-type">int</span>, max <span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-comment">// 因为前面我们获取了最大值，这里我们获取一下最大值的位数</span><br>   <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>   <span class="hljs-keyword">for</span> max%<span class="hljs-number">10</span> &gt; <span class="hljs-number">0</span> &#123;<br>      max /= <span class="hljs-number">10</span><br>      count++<br>   &#125;<br>   <span class="hljs-comment">// 给桶中对应的位置放数据</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= count; i++ &#123;<br>      <span class="hljs-comment">// 根据不同的位数，我们来获取10的n次方，用于后面获取每位的值</span><br>      theData := <span class="hljs-type">int</span>(math.Pow10(i))<br>      <span class="hljs-comment">// 建立空桶</span><br>      bucket := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>      <span class="hljs-comment">// 遍历数组</span><br>      <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(theArray); k++ &#123;<br>         <span class="hljs-comment">// 这里我们进行取余操作，目的是为了获取这个数组在每位上的值</span><br>         theResidue := (theArray[k] / theData) % <span class="hljs-number">10</span><br>         <span class="hljs-comment">// 获取到了位数后我们直接放入对应的桶中</span><br>         bucket[theResidue] = <span class="hljs-built_in">append</span>(bucket[theResidue], theArray[k])<br>      &#125;<br><br>      <span class="hljs-comment">// 一遍循环完之后需要把数组二维数据进行重新排序，比如数组开始是10 1 18 30 23 12 7 5 18 233 144 ，循环个位数</span><br>      <span class="hljs-comment">// 循环之后的结果为10 30 1 12 23 233 144 5 7 18 18 ，然后循环十位数，结果为1 5 7 10 12 18 18 23 30 233 144</span><br>      <span class="hljs-comment">// 最后循环百位数，结果为1 5 7 10 12 18 18 23 30 144 233</span><br>      <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><br>      <span class="hljs-comment">// 遍历我们的桶</span><br>      <span class="hljs-keyword">for</span> p := <span class="hljs-number">0</span>; p &lt; <span class="hljs-built_in">len</span>(bucket); p++ &#123;<br>         <span class="hljs-keyword">for</span> q := <span class="hljs-number">0</span>; q &lt; <span class="hljs-built_in">len</span>(bucket[p]); q++ &#123;<br>            <span class="hljs-comment">// 这里按照桶的结构，按桶的顺序把桶里面的数据放入数组中</span><br>            <span class="hljs-keyword">if</span> bucket[p][q] != <span class="hljs-number">0</span> &#123;<br>               theArray[x] = bucket[p][q]<br>               x++<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">break</span><br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>   fmt.Println(theArray)<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程</a>、<a href="http://interview.xiaoyou66.com/pages/817a23/">排序算法</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法、golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go关键字fallthrough用法</title>
    <link href="/2022/05/18/Go%E5%85%B3%E9%94%AE%E5%AD%97fallthrough%E7%94%A8%E6%B3%95/"/>
    <url>/2022/05/18/Go%E5%85%B3%E9%94%AE%E5%AD%97fallthrough%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>fallthrough：Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。</p><span id="more"></span><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   test:=<span class="hljs-string">&quot;abc&quot;</span><br>   <span class="hljs-keyword">switch</span> test[<span class="hljs-number">0</span>]&#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;The first word is a&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;The first word is b&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;The first word is c&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">default</span>:<br>      fmt.Println(<span class="hljs-string">&quot;default case&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2022/05/18/Go%E5%85%B3%E9%94%AE%E5%AD%97fallthrough%E7%94%A8%E6%B3%95/image-20220518163136308.png" alt="image-20220518163136308"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   test:=<span class="hljs-string">&quot;abc&quot;</span><br>   <span class="hljs-keyword">switch</span> test[<span class="hljs-number">0</span>]&#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;The first word is a&quot;</span>)<span class="hljs-comment">//去掉fallthrough</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;The first word is b&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;The first word is c&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">default</span>:<br>      fmt.Println(<span class="hljs-string">&quot;default case&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/18/Go%E5%85%B3%E9%94%AE%E5%AD%97fallthrough%E7%94%A8%E6%B3%95/image-20220518163244944.png" alt="image-20220518163244944"></p><p>注意:加了fallthrough后，会直接运行【紧跟的后一个】case或default语句，<strong>不论条件是否满足都会执行</strong>，后面的条件并不会再判断了</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang-Excel</title>
    <link href="/2022/05/03/golang-Excel/"/>
    <url>/2022/05/03/golang-Excel/</url>
    
    <content type="html"><![CDATA[<h3 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h3><h4 id="1-1安装"><a href="#1-1安装" class="headerlink" title="1.1安装"></a>1.1安装</h4><ul><li>安装命令</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-number">360</span>EntSecGroup-Skylar/excelize<br></code></pre></td></tr></table></figure><ul><li>如果您使用 <a href="https://blog.golang.org/using-go-modules">Go Modules</a> 管理软件包，请使用下面的命令来安装最新版本。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">复制代码<span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-number">360</span>EntSecGroup-Skylar/excelize/v2<br></code></pre></td></tr></table></figure><h4 id="1-2更新"><a href="#1-2更新" class="headerlink" title="1.2更新"></a>1.2更新</h4><ul><li>更新命令</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">复制代码<span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-number">360</span>EntSecGroup-Skylar/excelize<br></code></pre></td></tr></table></figure><h3 id="2-创建Excel文档"><a href="#2-创建Excel文档" class="headerlink" title="2.创建Excel文档"></a>2.创建Excel文档</h3><p>简单新建例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;github.com/360EntSecGroup-Skylar/excelize&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := excelize.NewFile()<br>    <span class="hljs-comment">// 创建一个工作表</span><br>    index := f.NewSheet(<span class="hljs-string">&quot;test&quot;</span>)<br>    <span class="hljs-comment">// 设置单元格的值</span><br>    f.SetCellValue(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>, <span class="hljs-string">&quot;Hello world.&quot;</span>)<br>    <span class="hljs-comment">// 设置工作簿的默认工作表</span><br>    f.SetActiveSheet(index)<br>    <span class="hljs-comment">// 根据指定路径保存文件</span><br>    <span class="hljs-keyword">if</span> err := f.SaveAs(<span class="hljs-string">&quot;test.xlsx&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="image-20220503161134166.png" alt="image-20220503161134166" style="zoom:67%;" /><h3 id="3-读取Excel文档"><a href="#3-读取Excel文档" class="headerlink" title="3.读取Excel文档"></a>3.读取Excel文档</h3><p>简单读取例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;github.com/360EntSecGroup-Skylar/excelize&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f, err := excelize.OpenFile(<span class="hljs-string">&quot;test.xlsx&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 获取工作表中指定单元格的值</span><br>    cell, err := f.GetCellValue(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 获取 Sheet1 上所有单元格</span><br>    rows, err := f.GetRows(<span class="hljs-string">&quot;Sheet1&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> rows &#123;<br>        <span class="hljs-keyword">for</span> _, colCell := <span class="hljs-keyword">range</span> row &#123;<br>            fmt.Print(colCell, <span class="hljs-string">&quot;\t&quot;</span>)<br>        &#125;<br>        fmt.Println()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更多使用方法请参考<a href="https://www.bookstack.cn/read/excelize-2.3/b2e09ee3ee36ed31.md">https://www.bookstack.cn/read/excelize-2.3/b2e09ee3ee36ed31.md</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Excel、golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>contentType类型详细版</title>
    <link href="/2022/05/03/contentType%E7%B1%BB%E5%9E%8B%E8%AF%A6%E7%BB%86%E7%89%88/"/>
    <url>/2022/05/03/contentType%E7%B1%BB%E5%9E%8B%E8%AF%A6%E7%BB%86%E7%89%88/</url>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">*.<span class="hljs-number">3</span>gpp    audio/<span class="hljs-number">3</span>gpp, video/<span class="hljs-number">3</span>gpp<br>*<span class="hljs-selector-class">.ac3</span>    audio/ac3<br>*<span class="hljs-selector-class">.asf</span>       allpication/vnd<span class="hljs-selector-class">.ms-asf</span><br>*<span class="hljs-selector-class">.au</span>           audio/basic<br>*<span class="hljs-selector-class">.css</span>           text/css<br>*<span class="hljs-selector-class">.csv</span>           text/csv<br>*<span class="hljs-selector-class">.doc</span>    application/msword    <br>*<span class="hljs-selector-class">.dot</span>    application/msword    <br>*<span class="hljs-selector-class">.dtd</span>    application/xml-dtd    <br>*<span class="hljs-selector-class">.dwg</span>    image/vnd<span class="hljs-selector-class">.dwg</span>    <br>*<span class="hljs-selector-class">.dxf</span>      image/vnd<span class="hljs-selector-class">.dxf</span><br>*<span class="hljs-selector-class">.gif</span>            image/gif    <br>*<span class="hljs-selector-class">.htm</span>    text/<span class="hljs-selector-tag">html</span>    <br>*<span class="hljs-selector-class">.html</span>    text/<span class="hljs-selector-tag">html</span>    <br>*<span class="hljs-selector-class">.jp2</span>            image/jp2    <br>*<span class="hljs-selector-class">.jpe</span>       image/jpeg<br>*<span class="hljs-selector-class">.jpeg</span>    image/jpeg<br>*<span class="hljs-selector-class">.jpg</span>          image/jpeg    <br>*<span class="hljs-selector-class">.js</span>       text/javascript, application/javascript    <br>*<span class="hljs-selector-class">.json</span>    application/json    <br>*<span class="hljs-selector-class">.mp2</span>    audio/mpeg, video/mpeg    <br>*<span class="hljs-selector-class">.mp3</span>    audio/mpeg    <br>*<span class="hljs-selector-class">.mp4</span>    audio/mp4, video/mp4    <br>*<span class="hljs-selector-class">.mpeg</span>    video/mpeg    <br>*<span class="hljs-selector-class">.mpg</span>    video/mpeg    <br>*<span class="hljs-selector-class">.mpp</span>    application/vnd<span class="hljs-selector-class">.ms-project</span>    <br>*<span class="hljs-selector-class">.ogg</span>    application/ogg, audio/ogg    <br>*<span class="hljs-selector-class">.pdf</span>    application/pdf    <br>*<span class="hljs-selector-class">.png</span>    image/png    <br>*<span class="hljs-selector-class">.pot</span>    application/vnd<span class="hljs-selector-class">.ms-powerpoint</span>    <br>*<span class="hljs-selector-class">.pps</span>    application/vnd<span class="hljs-selector-class">.ms-powerpoint</span>    <br>*<span class="hljs-selector-class">.ppt</span>    application/vnd<span class="hljs-selector-class">.ms-powerpoint</span>    <br>*<span class="hljs-selector-class">.rtf</span>            application/rtf, text/rtf    <br>*<span class="hljs-selector-class">.svf</span>           image/vnd<span class="hljs-selector-class">.svf</span>    <br>*<span class="hljs-selector-class">.tif</span>         image/tiff    <br>*<span class="hljs-selector-class">.tiff</span>       image/tiff    <br>*<span class="hljs-selector-class">.txt</span>           text/plain    <br>*<span class="hljs-selector-class">.wdb</span>    application/vnd<span class="hljs-selector-class">.ms-works</span>    <br>*<span class="hljs-selector-class">.wps</span>    application/vnd<span class="hljs-selector-class">.ms-works</span>    <br>*<span class="hljs-selector-class">.xhtml</span>    application/xhtml+xml    <br>*<span class="hljs-selector-class">.xlc</span>      application/vnd<span class="hljs-selector-class">.ms-excel</span>    <br>*<span class="hljs-selector-class">.xlm</span>    application/vnd<span class="hljs-selector-class">.ms-excel</span>    <br>*<span class="hljs-selector-class">.xls</span>           application/vnd<span class="hljs-selector-class">.ms-excel</span>    <br>*<span class="hljs-selector-class">.xlt</span>      application/vnd<span class="hljs-selector-class">.ms-excel</span>    <br>*<span class="hljs-selector-class">.xlw</span>      application/vnd<span class="hljs-selector-class">.ms-excel</span>    <br>*<span class="hljs-selector-class">.xml</span>    text/xml, application/xml    <br>*<span class="hljs-selector-class">.zip</span>            application/zip    <br>*<span class="hljs-selector-class">.xlsx</span>     application/vnd<span class="hljs-selector-class">.openxmlformats-officedocument</span><span class="hljs-selector-class">.spreadsheetml</span>.sheet<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>contentType类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="/2022/04/23/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/04/23/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><h4 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1.准备工作"></a>1.1.准备工作</h4><p>开始之前，你需要具备以下条件</p><ul><li>注册github账号</li><li>安装了node.js、npm，了解基础使用方法</li><li>安装并配置了git</li></ul><p>本文所用的环境</p><ul><li>windows10</li><li>node.js-12.19.0</li><li>git-2.35.1</li><li>hexo-4.3.0</li></ul><h4 id="2-搭建github博客"><a href="#2-搭建github博客" class="headerlink" title="2.搭建github博客"></a>2.搭建github博客</h4><h4 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1.创建仓库"></a>2.1.创建仓库</h4><p>新建一个名为<code>username.github.io</code>的仓库，其中username为自己设置的用户名，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是( <a href="http://test.github.io/">http://test.github.io</a> )了，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>注意：</p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</li></ol><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦</p><h4 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2. 绑定域名"></a>2.2. 绑定域名</h4><p>当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p><p>本文使用的是阿里云的域名，想要域名的话可以自己去申请然后进行备案。</p><p>绑定域名分2种情况：带www和不带www的。</p><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="/2022/04/23/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20220423202725658.png" alt="image-20220423202725658"></p><img src="image-20220423203039635.png" alt="image-20220423203039635" style="zoom: 80%;" /><p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，我自己是没有www的域名，所以更详细的情况可以参考(<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2)%E3%80%82">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2)。</a></p><p>另外说一句，在你绑定了新域名之后，原来的<code>你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p><h3 id="3-配置SSH-key"><a href="#3-配置SSH-key" class="headerlink" title="3.配置SSH key"></a>3.配置SSH key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/. ssh <span class="hljs-comment">#检查本机已存在的ssh密钥</span><br></code></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮件地址&quot;</span><br></code></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><img src="image-20220423203303276.png" alt="image-20220423203303276" style="zoom: 67%;" /><p>将刚复制的内容粘贴到key那里，title随便填，保存。</p><p>测试是否成功</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com <span class="hljs-comment"># 注意邮箱地址不用改</span><br></code></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><p>You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p><p>此时你还需要配置：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;liupeishen&quot;</span><span class="hljs-comment">// 你的github用户名，非昵称</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span>  <span class="hljs-string">&quot;xxx@163.com&quot;</span><span class="hljs-comment">// 填写你的github注册邮箱 这个邮箱应该要和生成SSH key的邮箱一致</span><br></code></pre></td></tr></table></figure><h3 id="4-安装配置hexo"><a href="#4-安装配置hexo" class="headerlink" title="4.安装配置hexo"></a>4.安装配置hexo</h3><h4 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1.hexo简介"></a>4.1.hexo简介</h4><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io/">http://hexo.io</a><br>        github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h4 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2. 原理"></a>4.2. 原理</h4><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h4 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h4><p>安装之前先来说几个注意事项：</p><ol><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li><li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li></ol><h4 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4. 安装"></a>4.4. 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo<br></code></pre></td></tr></table></figure><h4 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5. 初始化"></a>4.5. 初始化</h4><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>D:\blog\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /d/blog/hexo/<br>$ hexo init<br></code></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><img src="image-20220423204008873.png" alt="image-20220423204008873" style="zoom:67%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g <span class="hljs-comment"># 生成</span><br>$ hexo s <span class="hljs-comment"># 启动服务</span><br></code></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><img src="image-20220423204029772.png" alt="image-20220423204029772" style="zoom:67%;" /><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p><p><a href="http://blog.liuxianan.com/windows-port-bind.html">http://blog.liuxianan.com/windows-port-bind.html</a></p><p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，可以替换一个自己喜欢的官方主题。</p><h4 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6.修改主题"></a>4.6.修改主题</h4><p>个人比较喜欢fluid主题风格，可以参考用户手册来进行安装(<a href="https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B%E3%80%82">https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B。</a>)</p><p>下载好的主题会在themes文件夹里，如下:</p><img src="image-20220423204524677.png" alt="image-20220423204524677" style="zoom:80%;" /><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，然后重新执行<code>hexo g</code>来重新生成。：</p><img src="image-20220423204620753.png" alt="image-20220423204620753" style="zoom:80%;" /><p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p><h4 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7. 上传之前"></a>4.7. 上传之前</h4><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h4 id="4-8-上传到github"><a href="#4-8-上传到github" class="headerlink" title="4.8. 上传到github"></a>4.8. 上传到github</h4><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p><p>正确写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:liuxianan/liuxianan.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">github</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">https://github.com/liuxianan/liuxianan.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Deployer not found:</span> <span class="hljs-string">github</span> <span class="hljs-string">或者</span> <span class="hljs-attr">Deployer not found:</span> <span class="hljs-string">git</span><br></code></pre></td></tr></table></figure><p>原因是还需要安装一个插件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm install hexo-deployer-git <span class="hljs-attr">--save</span><br></code></pre></td></tr></table></figure><p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p><p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会：</p><p><img src="/2022/04/23/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20160818_140441_769_5024.png" alt="img"></p><h4 id="4-9-保留CNAME、README-md等文件"><a href="#4-9-保留CNAME、README-md等文件" class="headerlink" title="4.9. 保留CNAME、README.md等文件"></a>4.9. 保留CNAME、README.md等文件</h4><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：</p><p><img src="/2022/04/23/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/20160818_141037_580_8035.png" alt="img"></p><p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p><h4 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10. 常用hexo命令"></a>4.10. 常用hexo命令</h4><p>常见命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;postName&quot;</span> <span class="hljs-meta">#新建文章</span><br>hexo <span class="hljs-keyword">new</span> page <span class="hljs-string">&quot;pageName&quot;</span> <span class="hljs-meta">#新建页面</span><br>hexo generate <span class="hljs-meta">#生成静态页面至public目录</span><br>hexo server <span class="hljs-meta">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br>hexo deploy <span class="hljs-meta">#部署到GitHub</span><br>hexo help  <span class="hljs-meta"># 查看帮助</span><br>hexo version  <span class="hljs-meta">#查看Hexo的版本</span><br></code></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo n == hexo <span class="hljs-keyword">new</span><br>hexo g == hexo <span class="hljs-keyword">generate</span><br>hexo s == hexo server<br>hexo d == hexo deploy<br></code></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s -g <span class="hljs-comment">#生成并本地预览</span><br>hexo d -g <span class="hljs-comment">#生成并上传</span><br></code></pre></td></tr></table></figure><h4 id="4-11-config-yml"><a href="#4-11-config-yml" class="headerlink" title="4.11. _config.yml"></a>4.11. _config.yml</h4><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p><p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><h4 id="4-12-写博客"><a href="#4-12-写博客" class="headerlink" title="4.12. 写博客"></a>4.12. 写博客</h4><p>定位到我们的hexo根目录，执行命令：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&#x27;hexo-github搭建个人博客&#x27;</span><br></code></pre></td></tr></table></figure><p>hexo会帮我们在<code>_posts</code>下生成相关md文件：</p><img src="image-20220424154356985.png" alt="image-20220424154356985" style="zoom: 80%;" /><p>我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：</p><img src="image-20220424154424000.png" alt="image-20220424154424000" style="zoom:80%;" /><p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p><p>一般完整格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: postName #文章页面上的显示名称，一般是中文<br>date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改<br>categories: 默认分类 #分类<br>tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格<br><span class="hljs-section">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="hljs-section">---</span><br><br>以下是正文<br></code></pre></td></tr></table></figure><h5 id="4-12-1-如何让博文列表不显示全部内容"><a href="#4-12-1-如何让博文列表不显示全部内容" class="headerlink" title="4.12.1. 如何让博文列表不显示全部内容"></a>4.12.1. 如何让博文列表不显示全部内容</h5><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 前言</span><br><br>使用github pages服务搭建博客的好处有：<br><br><span class="hljs-bullet">1.</span> 全是静态文件，访问速度快；<br><span class="hljs-bullet">2.</span> 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；<br><span class="hljs-bullet">3.</span> 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；<br><br>&lt;!--more--&gt;<br><br><span class="hljs-bullet">4.</span> 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；<br><span class="hljs-bullet">5.</span> 博客内容可以轻松打包、转移、发布到其它平台；<br><span class="hljs-bullet">6.</span> 等等；<br></code></pre></td></tr></table></figure><h3 id="5-插入图片"><a href="#5-插入图片" class="headerlink" title="5.插入图片"></a>5.插入图片</h3><p>众所周知，在md文件中插入图片的语法为<code>![]()</code>。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><p>这种方式算是有利有弊。</p><p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p><p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p><p>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当该配置被应用后，使用<code>hexo new</code>命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p><blockquote><p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。</p><p>如在一个文件目录下，博客名为<code>1.md</code>，相应的存在一个<code>1</code>文件夹存放图片<code>image.jpg</code>。</p><p>在Typora编辑器中，普通的md文件使用<code>![](1/image.jpg)</code>能在编辑器中正常显示图片。</p><p>在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。</p><p>此时应该使用这样的方式来引入图片：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% asset<span class="hljs-emphasis">_img image.jpg 这是一张图片 %&#125;</span><br></code></pre></td></tr></table></figure></blockquote><p>虽然可以正常引用图片了，但是这种引用图片的方式在本地不能查看图片情况。。。</p><h4 id="5-1-图片插件"><a href="#5-1-图片插件" class="headerlink" title="5.1.图片插件"></a>5.1.图片插件</h4><p>插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p><h4 id="5-2-hexo与Typora的完美结合"><a href="#5-2-hexo与Typora的完美结合" class="headerlink" title="5.2.hexo与Typora的完美结合"></a>5.2.hexo与Typora的完美结合</h4><p>上述是从文章资源文件夹中引用图片，前提是<strong>先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p><p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置</code>或者直接<code>&lt;C-,&gt;</code>进入设置。</p><img src="hexo和Typora的完美结合.jpg" alt="Typora与hexo的完美结合" style="zoom: 50%;" /><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p><p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p><p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p><p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p><img src="image-20201012140945525.png" alt="image-20201012140945525" style="zoom: 67%;" /><p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>本文主要是供自己学习用，当然也欢迎大家进行参考。</p><img src="image-20220424155234568.png" alt="image-20220424155234568" style="zoom: 50%;" /><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>hexo+github搭建博客:<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2</a></p><p>如何插入图片:<a href="https://www.cnblogs.com/bzsheng/p/13802829.html">https://www.cnblogs.com/bzsheng/p/13802829.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo、github、博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
